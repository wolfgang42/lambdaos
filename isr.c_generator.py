from isr_exceptions import exceptions

print """// This file is autogenerated by isr.c_generator.py
// DO NOT EDIT IT MANUALLY!\n\n"""

print """#include "lib/printf.h"
#include "isr.h"
#include "kernel.h"
#include "idt.h" """

for i in range(0,32):
	print "extern void isr"+str(i)+"();"

print """/* We set the access
 *  flags to 0x8E. This means that the entry is present, is
 *  running in ring 0 (kernel level), and has the lower 5 bits
 *  set to the required '14', which is represented by 'E' in
 *  hex. */
void isrs_install() {"""
for i in range(0,32):
	print "\tidt_set_gate("+str(i)+", (unsigned)isr"+str(i)+", 0x08, 0x8E);"
print "}"

print "char *exception_messages[] = {"
for i in range(0,32):
	print '\t"'+exceptions[i][0]+'",'
print "};"

print """/* All of our Exception handling Interrupt Service Routines will
*  point to this function. This will tell us what exception has
*  happened! Right now, we simply halt the system by hitting an
*  endless loop. All ISRs disable interrupts while they are being
*  serviced as a 'locking' mechanism to prevent an IRQ from
*  happening and messing up kernel data structures */
void fault_handler(struct regs *r) {
	if (r->int_no <= 31) {
		/* Display the description for the Exception that occurred.
		 *  In this tutorial, we will simply halt the system using an
		 *  infinite loop */
		kernel_panic(exception_messages[r->int_no]);
	} else {
		char buf[18];//len("Unknown ISR: ")+len(str("65535"))
		sprintf(buf, "Unknown ISR: %u", r->int_no);
		kernel_panic(buf);
	}
}"""
