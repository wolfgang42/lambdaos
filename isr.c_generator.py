from isr_exceptions import exceptions

print """// This file is autogenerated by isr.c_generator.py
// DO NOT EDIT IT MANUALLY!\n\n"""

print """#include "driver/vga.h"
#include "kernel.h"
extern void idt_set_gate(unsigned char num, unsigned long base, unsigned short sel, unsigned char flags);
/* This defines what the stack looks like after an ISR was running */
struct regs {
	unsigned int gs, fs, es, ds;      /* pushed the segs last */
	unsigned int edi, esi, ebp, esp, ebx, edx, ecx, eax;  /* pushed by 'pusha' */
	unsigned int int_no, err_code;    /* our 'push byte #' and ecodes do this */
	unsigned int eip, cs, eflags, useresp, ss;   /* pushed by the processor automatically */ 
};"""

for i in range(0,32):
	print "extern void isr"+str(i)+"();"

print """/* We set the access
 *  flags to 0x8E. This means that the entry is present, is
 *  running in ring 0 (kernel level), and has the lower 5 bits
 *  set to the required '14', which is represented by 'E' in
 *  hex. */
void isrs_install() {"""
for i in range(0,32):
	print "\tidt_set_gate("+str(i)+", (unsigned)isr"+str(i)+", 0x08, 0x8E);"
print "}"

print "char *exception_messages[] = {"
for i in range(0,32):
	print '\t"'+exceptions[i][0]+'",'
print "};"

print """/* All of our Exception handling Interrupt Service Routines will
*  point to this function. This will tell us what exception has
*  happened! Right now, we simply halt the system by hitting an
*  endless loop. All ISRs disable interrupts while they are being
*  serviced as a 'locking' mechanism to prevent an IRQ from
*  happening and messing up kernel data structures */
void fault_handler(struct regs *r) {
	if (r->int_no <= 31) {
		/* Display the description for the Exception that occurred.
		 *  In this tutorial, we will simply halt the system using an
		 *  infinite loop */
		kernel_panic(exception_messages[r->int_no]);
	} else {
		kernel_panic("Unknown ISR!");
	}
}"""
